# dismathportfolio-kienairaa
dismathportfolio-kienairaa created by Classroom for GitHub

Roldan, Kien Aira D.   DISMATH EL

#WEEK 1
* This first week I was introduced to a new course of Discrete Mathematics.
* I learned that this course is different from any other math subjects because this talks about logic and proof.
* After the questions about the Knights and Knaves, I realized that in this course, I should be able to think critically and logically.
* I learned new concepts like Propositions, how to distinguish whther a given statement is a proposition, Truth Table, how helpful this table is.
* Logical Connectives:
 * ¬ Negation
 * ∧ Conjunction
 * ∨ Disjunction
 * ⊕ Exclusive or
 * → Conditional
 * ↔ Biconditional

#WEEK 2
* We were introduced on proving using Logical Equivalences.
* This topic got me confused becuase of the different laws involved in it.
* It took me quite some time to be able to fully understand that topic.But still I'm not so confident about those Logical Equivlences.
* I also learned about Existential Quantifiers which is onlky true for some values and Universal Quantifiers which is always true for any possible values.
* This week, we were also taught about the Rules of Inference.
* This topic is also quite difficult for me just like the Logical Equivalences because I must be familiar with every rule and when it must be used in proving.

#WEEK 3
* This week, we were introduce to a new topic which is the different Methods of proofs.
* I was able to easily understand Direct Proof and Proof by Contraposition becuase it seems to be just like proving using mathematical ways.
* I think the easiest among the methods so far is the Vacuous and Trivial Proofs. Because in Vacuous Proof, we just need to show that p is false so that the given statement is already proven and in Trivial Proof, q must be proven to be true so that the statement will be proven true.
* We discussed the last method of proof which is the Proof by Equivalence.
* This proof is quite easy beacuse it is just proving that a biconditional is true using the other methods of proof.

#WEEK 4
* This week, we learned about Mathematical Induction.
* Mathematical Induction includes two steps: 
  * 1.) Basis Step 
  * 2.) Direct Proof.
* We were also introduced to Summation.
* This one's quite confusing becausew we were given an example where we need to look for an equation. I'm not really good iin coming up with an equation for a certain example that's why I find this topic quite challenging.
* Still, we need to prove that the equation we come up with is true using Mathematical Induction.
* Then we were introduced with Recursive/Inductice Definition.
* The first step is Basis step where we specify the value of the function at zero. And the  next step would be find an equation for finding the value of the integer.
* Lastly, we were inrtoduced to Recursive Definition
  * an algorithm is recursive  if it solves a problem by reducing it to an instance of the same problem with smaller input.

#WEEK 5
* Recursive Algorithm and Program correctness were introduced to us.
* * We continued the discussion about program correctness where we need to prove that the program always gives the correct output.
* There are two step two verify a program:
  * 1.) show that the correct answer is obtained if the program teminates (prgram correctness) and 
  * 2.) show that the program always terminates.
* I also learned about Initial Assertion which hives the properties the the input must have, and the Final Assertion which the output must have.
* I also learned about the Hoare Triple: *p{S}q*.
* The use of the Rules of Inference with Program Correctness was also taught.
* I also learned about Zeno's Paradox and the Power Series.
* I discovered about the Set Theory and what a Power Set is and what Cardinality means.
* Then we also discussed the Set Theory.
* I learned that in a Set, the order and the quantity is not important in knowing if two sets are the same as long as they have the same elements in it.
* We also reviewed the Venn Diagram, which also includes the Set Operations:
  * Union
  * Intersection
  * Set Difference
  * Symetric Difference
* I also learned that if all elements of Set A are also elements of B, then set a is a subset of B.
* Power Series were also introduced to our class.

#WEEK 6

* Cardinality was also discussed which is the number of elements it contains if A is a set and we denot it by *{A}*.
* This week, we started dicsussing about Functions and that it is sometimes called mappings or transformations.
* I also learned how to determine the domian and codomain of a function.
* Different types of Functions:
  * One-To-One Function
    * If and only if *f(a)=f(b)* implies that *a=b* for all *a* and *b* in the domain of *f*.
  * Onto Function
    * If the range and domain are equal and that every member of the codomain is the image of some elementof the domain.
  * Bijection
    * If it is both *one-to-one* and *onto*.
    * Also called *one-to-one correspondence*.

#WEEK 7
*No classes

#WEEK 8
* Algorithm
  * a finite set vof precise insrtuctions for performing a computation or for solving as problem
* We were taught on how to find the maximum and minimum value in a finite sequence of integers using the first example given.
* We solve a probelm in algorithm by providing a *Pseudocode*.
* Pseudocode
  * a high-level desciprtion of an algorithm that uses structural convention of a programming language, but is intended for human reading
*Properties of Algorithms
  * Input
  * Output
  * Definiteness
  * Correctness
  * Finiteness
  * Effectiveness
  * Generality
 * We were also intrpduced to the different *Searching Algorithms*.
   * Linear Search
     *Also called *Sequential Search*
   * Binary Search
     * It proceeds by comparing the element to be located to the middle term of the list.
     * The list is then split into two smaller sublists of the same size, or where one of these smaller listss has one fewer term than the other.
     * The search continues by restricting the search to the appropriate sublist based on the comparison of the element to be located and the middle term.


#WEEK 9
* This week, we were ntroudced to *Sorting Algorithm*.
* Sorting is putting the elements of a set into amlist which these elements sre in increasing order.
* Types of Sorting
  * The Bubble Sort
    * It puts a list into increasing order by successively comparing adjacent elements, interchanging them if they are in the wrong order.
  * The Insertion Sort
    * It compares the second lement with the first elementand inserts it before the first element if it does not exceed the first element and after the first element if it exceeds the first element.
 * We were also introduced to *Greedy Algorithms*
 * Greedy Algorithms
   * Algorithms that make what seems to be the "best" choice in each step.
   * Selects the best choice at each stepp, instead of considering all sequences of steps that may lead to an optimal solution.
 * Since I know I am not verygood at computer programming, it was quite hard for me to follow the discusion.
 * Though weonly used pseudocode for this algorithm, it was stilla bit concfusing for me.

#WEEK 10
* This week, we learned about the *Growth of Functions*.
* This Growth of Function is describes using *The Big-O Notation*.
* Big-O Notation (upperbound)
   * Let *f* and *g* be functions from the set of integers or the set of real numbers to the set of numbers.
   * *f(x)* is *O(g(x))* if there are constants *C* and *k* such that *|f(x)| <= C|g(x)|* whenever *x > k*.
* Big-Omega Notation (lowerbound)
* Big-Theta Notation
   * We use this notation when we want to give both an upper and a lower bound on the size of a function *f(x)*, relative to a reference function *g(x)*
 This Notationsarequiteconfusing for me especially when you try to prove is afunctions is a notationof the given.
* We also learned about the *Complexity of Algorithms*.
* Time Complexity
   * It can be expressed in terms of the number of operations used by the algorithm when ther input has a particular size.
   * Worst-Case Complexity
     * By the worst-case performance of an algorithm, we mean the largest number of operations needed to solve the given problem using the algorithm on input os specified size.
     * Worst-case analysis tells us how many operation an algorithm requires to guarantee that it will produce a solution.
* When we learned this timecomplexity,i understand whatwas being toldabout it but when complicated given ariose, it got me so confused on how to getthecomplexity of a function.
* It was difficult for me maybe also because I got a hard time udenrstanding how to prove that a function is a notation of something and getting the time complexity is easier if you haveyourt Big-Theta Notation.
* This week we were also introduced to a new topic which is the *Division* and *Modulo Operator*.
* This topic was way more easier than the previous one because it only involves division which we learned since our elementary days.
* We use *div* to get the quotient and *mod* to get the remainder.
* We also learned about *Caesar Cipher* where we add three more letters to the given letter that we have to come up with the real letter hidden in it.
* This lesson was quite interesting because it was like we were being taught on how to effectively write hidden messages.

#WEEk 11
* No classes

#WEEK 12
* This week we started Graph Theory and it was defined as discrete structures consiting of vertices and edges that connect these vertices.
* I learned that graph may also be defined as a set of vertices and edges, Graph *G = {V, E}* and also that *V = a nonempty set of vertices or nodes* and *E = a set of edges*.
* We also encountered *Endpoints*, the vertices associated with each edge in a graph.
* During this discussion I think the focus was for us to understand quite a number of terms that we may encounter in this Graph Theory lesson.
* The terms that was introduced to us was...
  * *Degree*
    * it is the number of edges incident in a veretex of a graph (undirected)
    * We also got the infromation that the loop at a vertex counts as two degrees.
  * *Handshake Theorem*
    * We use this theorem to find how many edges a graph contains given its vertices and the degerees of it.
  * *Subgraph*
    * A graph, for example B is said to be a subgraph of a certain graph, for example A if the vertices and edges of graph B is a subset of the vertices and edegs of graph A.
  * *Union*
    * This is the combinatuion of two graphs.
  * *Path*
    * A sequence of edges that begins at a vertex of a graph and travels from vertexto vertex along edges of the graphs.
  * *Euler Circuit*
    * We define this as a simple circuit that passes through every edge of the graph only once and will go back to the vertex where it started without passing through and edge more than once.
    * We were also taught that if all nodes of a graph have even degrees then it is an Euler Ciruit.
  * *Euler Path*
    * This is a simple path that asses throught every edge exactly once.
    * We also learned that to find an Eauler Path, the graph must have exatcly two nodes with odd degree and that this two nodes with odd degree will be the beginning or end of path.
  * *Hamilton Path*
    * We now define this as a simple circuit that passes through every vertex of the graphy only one returning back to the vertex where it started not passing any vertex more than once.
  * *Hamilton Path*
    * This is a path that passes each end every veretx of the graph without passing a vertex more than once.
    * We do not need to pass every edge as long as we were able to passed through each vertex already.
  * *Adjacency Matrix*
    * A matrix representing a pgraph using the adjacency of vertices
    * We use 0 if there is no adjacency and 1 if there is.
  * *Incidence Matrix*
    * A matrix representing a graph using the incidence of edeges and vertices
  * *Isomorphism of Graph*
    * We say that a graph is isomoprphic of a graph is there is a one-to-one correspondence to each vertices of both graph.
  * *Planar Graphs*
    * This is a graph that can be drawn in the plane without crossing the edges.
      * This Planar graph is quite confusing because you must really try and find and draw several time, like a trial-and-error, to find if it is a planar or not.
      * We were taught about the basic structure of K3,3 and K5 which are both nonplanar
  * *Euler's Formula*
    * This formula is *r = e - V + 2*
    * We use this to find the number of regions inb a graph given the number of vertices and its corresponding edges.
  * *Kuratowski's Theorem*
    * This is a nonplanar graph if and only if it contains a subgraph homeomorphic to K3,3 and K5 which are both nonplanar.
    * This is quite confusing since you'll be needing to fuly understand and define homeomorphic graph which involves that division or removing of a vertx in a graph to reduce it to either K3,3 or K5
    * What's difficult for me is how to show that a graph is a hemeomorphic of K3,3 or K5 since I'm not really confident mainulating the drawing of the graph.
 
#WEEK 13
* This week we started discussing about *Graph Coloring*.
* This *Graph Coloring* is an assignment oif colors to the vertices of a graph but no two adjacent vertices must have the same color.
* *Chromatic number* was also taught to class which is the minimum number of colors needed for coloring a graph.
* In this certain topic, we wre taught to recycle colors which means that we need to repeat a color as longs as it will not be the same as to its incidents.
* *Four Color theorem* is a chromatic number of a graph which is no greater than four.
* But this theorem only applies to a planar graph so we can expect to have more than four colors if we have a nonplanar graph.
* We also started discussing about *Trees*, a data structure that emulates a heirarchical tree structure with a set of linked nodes.
* This Tree can be related to the tree that we know because the vertext where it started is called a root and it ends at the leaves.
* We were also gicen imprtant note that if tehre is a loop, then it is not a tree.
* We can call the basic struture of Tree as *Rooted Tree* because we defined it as a tre in whcih on vertes has been designed as the root and everye dge is directed away from the root.
* We also learned that we can call tha branches of the root as the parent, the brancehs of the parent as child and siblings for the same parent.
* We also defined the root as the ancestors which we can actually relate to a literal family tree.
* We also learned that a rooted tree is called an *m-ary tree* if every internal vertex has no more than m children.
* For me, it is quite is to define an *m-ary tree* because you'll onlky need to pay vattention to the number of branches of each vertices.
* The next is the *Order Rooted Tree*, a rooted tree where the children of each internal vertes are order.
* This got me a bit confused becasue when it was discussed to us, it atcually involves a numbering of vertex whcih I don't undertsand why.
* We were also taught about the *Properties of Trees*
  * A tree with *n* vertices has *n-1* edges.
  * A full *m-ary* tree with *i* internal vertices contains *n = mi + 1*
  * A full *m-ary* tree with...
    * *n* vertices has *i = (n-1)/m* internal vertices and *l = [(m-1)n+1]/m* leaves
    * *i* internal vertcies has *n = m +1* vertcies and *l = (m-1)i+1* leaves.
* This week,we also learned about *Finite-State Machines*, consists of a finite set S of *states*, a finite *input alphabet I*, a finite *output alphabet O*, a *transition function f* that assigns to each state and input pair a new state.

#READING ASSIGMENTS
* *Tree traversal* is a listing of the vertices of a tree.
* *Spanning Tree* is a tree containing all vertices of a graph.
* Binary relation from A to B is a subset of *A x B*
* *Relation on A* is a binary relation from A to itself
* A relation *R* on *A* is reflexive if *(a, a)* is an element of *R* for all *a* is an element of *A*
* * A relation *R* on *A* is symmetric if *(b, a)* is an element of *R* whenever *(a, b)* is an element of *R*
* * A relation *R* on *A* is transitive if *(a, b)* is an element of *R* and *(b, c )* is an element of R implies that *(a, c)* is an element of *R*
* *|Closure of a Relation R* with respect to a property P: the relation *S* (if it exists) that contains *R*, has property *P*, and is contained within any relation taht contains *R* and has property *P*.
* *Equivalence relations* is a relation on a set A if it is reflexive, symmetric, and transitive


Kien Aira D. Roldan//Dismath-EL
